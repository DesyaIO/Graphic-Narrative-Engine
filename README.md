Приветствую уважаемых проверяющих преподавателей по инфроматике кафедры 317! Это итоговое тестовое задание первого семестра Пантелеева Захара, студента группы M3O-137БВ-25!
=
Небольшое вступление:
=
Моя игра конечно показывает моё владение программированием в ООП, пользование классами, но скорее своим "творением" я хотел продемонстрировать свою(и не только) небольшую боль, а скорее очень интересную дисциплиную - Начертательная и инженерная графика.

Лабораторная работа номер 2, которую я выполнил скучненько, но просто показал работу с классами почему-то была оценена несправедливо, по этому это ИТЗ - мой порыв творчества, боли и всего сразу. :3

Искренне говоря - весь код был написан горячо, с любовью, как и весь сюжет игры.

По просьбе уважаемых преподавателей кафедры 317. Все функции имеют аннотации и некоторые куски кода описаны комментариями(хотя я не понимаю зачем нужно комментирование кода если там и так все понятно).

**ОЧЕНЬ ВАЖНОЕ ПРИМЕЧАНИЕ!!!**
=
Чтобы моя игра работала именно так как задумывалась, её нужно запускать именно через терминал, то есть в проводнике в папке проекта нужно открыть main.py с помощью Python. НЕ ПАЙЧАРМА И НЕ IDLE!!! У питона такой прикол, что очистка консоли да и красивое форматирование всего (то к чему я стремился и очень много к этому приложил сил и энергии) не отображается и не работает должным образом. 
\
\
Спасибо за понимание!

Как играть: краткое руководство
==
После запуска игры вы увидите:

Меню сохранений - выберите слот или создайте нового персонажа

Основной геймплей - читайте историю и делайте выборы

Доступные команды во время игры:

инв - просмотреть инвентарь

сохр - сохранить игру

выход - выйти из игры

Ключевые механики:

Время ограничено - зачет в 19:20!

Ваши выборы влияют на финальную оценку

Собирайте предметы и достижения

Следите за флагами (они скрыты, но влияют на игру)

Возможное концовки
==
**СЕЙЧАС БУДУТ СПОЙЛЕРЫ !!! ЛУЧШЕ ВСЕГО ПРОЙДИТЕ ДЛЯ НАЧАЛА ИГРУ!!! **

В игре 5 возможных концовки, которые зависят от:

Если в начале игры вы решили не купаться и посмотреть тик ток - то вы проиграли.

Питания - если ни разу не поели → обморок

Баллы (total_score):
Менее 2.5 → "Удовлетворительно" (3)
2.5-3.5 → "Хорошо" (4)
Более 4.5 → "Отлично" (5)

total_score зависит в первую очередь от выборов, которые вы совершали во время всей игры. То есть все выборы - это и есть ваша конечная оценка на зачете.

Как работает моя игра? Что можно выделить
=
Как работает моя игра? По сути я в файле GameEngine.py написал своеобразный движок, который рассказывает мою историю. Игра - своеобразный квест-визуальная новелла. То есть в ней есть система выборов и отображения текста, а так же посимвольный красивый вывод. 

Вся история - именно то, что я хотел рассказать Вам, кроется в json файлах в папке data. Там есть 3 файла связанные с выборами. Самый простой файл или скорее задумка файла - это narrative_text.json. В нем храняться самые простые текстовые блоки, которые просто выводяться да и все. По желанию можно добавить в этот объект поле с conditions то есть условием выполнения. 

Кстати про условия выполнения conditions - это условие будет ли показываться опеределенный блок или choice то есть выбор. Он является простым логическим если в него мы пишем булевое условие, где ключевыми переменными являются флаги, которые прописаны в конфиге и в переменной flags у игрока. То есть если нужно добавить флаг, от котого будет зависеть исход игры или будет ли какой-то выбор или нет, то нужно его добавить в конфиг и в игрока.

Файл с выборами choices.json - там мы придумываем что наш игрок вообще может выбрать, какие флаги, предметы и тд и тп получит. А block_choices.json - это полноценная панель выборов - она совмешает в себе все выборы, а уже сам движок во время исполнения игры решает какие choice отображать а какие нет.

Выше был упомянут конфиг - config.py - файлик в который я поместил большую часть различных констант, в нем так же описаны некоторые игровые моменты, котороые перечислять очень долго. Сам конфиг подробно описан и каждая переменная все говорит за себя.

Механики, которые я конкретно где-то как-то реализовал и показал, что умею:
=
1) Элементрная работа с json форматом / Реализация сохранений (автосохранение / удаление сохранений / выбор сохранения в начале игры)
2) Самый основной скрипт - GameEngine - своего рода движок, который по моим правилам проигрывает блоки текста и блоки выбора, с последующими добавлениями разных предметов и флажков.
3) Использовались все принципы ООП
Принципы ООП, которые были применены и где:\

**Инкапсуляция:**
````
@dataclass
class Player:
    _name: str  # приватное поле!!!
    _time_left: int
    _inventory: Inventory
    _flags: Dict[str, bool] = field(....
    мои поля какие-то....
     @property
    def name(self): # публичный геттер!!!
        return self._name
    def set_flag(self, flag_name: str, value: bool = True): # публичный сеттер
        if flag_name:  # Проверяем, что флаг не пустая строка
            self._flags[flag_name] = value
````
**Наследование и полиморфизм. Наследование - два блока с похожей логикой наследуются от абстрактного класса - GameBlock. Полиморфизм - одно название один вызов, а реализация разная у меня именно в блоках моего движка TextBlock и ChoiceBlock, они все унаследованы от GameBlock, который я сделал абстрактным. Все методы декорированы abstractmethod из библиотеки ABC**
\
````
from abc import ABC, abstractmethod
from typing import List, Union


class GameBlock(ABC):
    """Абстрактный базовый класс для ВСЕХ блоков игры"""

    @property
    @abstractmethod
    def id(self) -> str:
        """ID блока"""
        pass

    @property
    @abstractmethod
    def next_block(self) -> Union[str, List[str], None]:
        """ID следующего блока (может быть строкой, списком или None)"""
        pass
       ..... и тд
````
\
![img.png](images/img.png)
В коде именно так используется сам полиморфизм \
**Абстракция: то есть выделение существенных характеристик объекта и игнорирование несущественных. В моем проекте абстракция реализована очень много где. Один из примеров это код выше ;3** \

Некоторые вещи
==
Вся архитектура проекта так же основана на некоторых принципах SOLID.

1) **Single Responsibility Principle** (Принцип единственной ответственности)
Каждый класс отвечает только за одну вещь:

GameEngine - управление игровым процессом

DataManager - работа с сохранениями

GameStateManager - управление состояниями

Player - хранение данных игрока

2) **Open/Closed Principle** (Принцип открытости/закрытости)
Классы открыты для расширения, но закрыты для модификации:

GameBlock - абстрактный класс для расширения

Конфик - config.py

3) Так же есть и другие принципы солид, но они реализованы не так явно.

Небольшая помарка
=
В моей игре всего 5 концовок, на каждую из них я прошел игру. Однако я не могу проверить все сценарии работы моей игры. Я искренне верю, что именно когда Вы, проверяющий мою игру, пройдете игру так как я задумывал и рассказал во втором блоке моего ридми.
\
Спасибо за внимание, хорошего настроения!